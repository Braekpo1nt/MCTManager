package org.braekpo1nt.mctmanager.games.game.capturetheflag;

import java.util.ArrayList;
import java.util.List;

public class RoundManager {
    
    /**
     * The schedule handled by this round. Each element of the outer list
     * is a round. 
     */
    private List<List<MatchPairing>> schedule;
    
    private int currentRoundIndex = 0;
    
    public int getCurrentRoundIndex() {
        return currentRoundIndex;
    }
    
    public int getMaxRounds() {
        return schedule.size();
    }
    
    /**
     * Generates a schedule for the teams to face off. This was generated by ChatGPT then modified slightly to
     * fit the application. 
     * @param teamIds the teamIds to generate the schedule for
     * @param numOfArenas the number of arenas (each arena fits 2 teams)
     * @return A list where each entry is the {@code numOfArenas} {@link MatchPairing}s for each round. The size
     * of the returned list will be the number of rounds. 
     */
    public static List<List<MatchPairing>> generateSchedule(List<String> teamIds, int numOfArenas) {
        int t = teamIds.size();
        List<List<MatchPairing>> schedule = new ArrayList<>();
        int rounds = (t % 2 == 0) ? t - 1 : t;
        
        // Clone the teams list so as not to modify the original
        List<String> rotatingTeams = new ArrayList<>(teamIds);
        
        for (int round = 0; round < rounds; round++) {
            List<MatchPairing> roundMatches = new ArrayList<>();
            
            for (int i = 0; i < t / 2; i++) {
                MatchPairing match = new MatchPairing(rotatingTeams.get(i), rotatingTeams.get(t - 1 - i));
                roundMatches.add(match);
            }
            
            // Rotate teams, keeping the first one fixed
            rotatingTeams.add(1, rotatingTeams.remove(rotatingTeams.size() - 1));
            
            // Split matches into groups for each arena
            for (int i = 0; i < roundMatches.size(); i += numOfArenas) {
                int end = Math.min(i + numOfArenas, roundMatches.size());
                schedule.add(new ArrayList<>(roundMatches.subList(i, end)));
            }
        }
        
        return schedule;
    }
    
}
