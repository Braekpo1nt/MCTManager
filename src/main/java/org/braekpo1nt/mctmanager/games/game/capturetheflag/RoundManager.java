package org.braekpo1nt.mctmanager.games.game.capturetheflag;

import com.google.common.base.Preconditions;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.*;

public class RoundManager {
    
    /**
     * The schedule handled by this round. Each element of the outer list
     * is a round. 
     */
    private List<List<MatchPairing>> schedule = new ArrayList<>();
    /**
     * the played {@link MatchPairing}s this game. Useful for when new teams join, we can re-generate matches
     * and remove already played ones. In the future, also could be useful for tracking wins, but would
     * need to be a map, and would need to be tracked by round. 
     */
    private List<MatchPairing> played = new ArrayList<>();
    
    private int currentRoundIndex = 0;
    
    /**
     * @param teamId the teamId to check
     * @param round the round to check
     * @return true if the given teamId is playing in the given round, false if they are on-deck
     */
    public static boolean teamIsPlaying(String teamId, List<MatchPairing> round) {
        for (MatchPairing matchPairing : round) {
            if (matchPairing.containsTeam(teamId)) {
                return true;
            }
        }
        return false;
    }
    
    /**
     * @param teamId the teamId to check
     * @param round the round to check
     * @return the opposite teamId of the given teamId in the given round (if they are present), null if the given team is on-deck
     */
    public static @Nullable String getOppositeTeam(String teamId, List<MatchPairing> round) {
        MatchPairing matchPairing = getMatchPairing(teamId, round);
        if (matchPairing == null) {
            return null;
        }
        return matchPairing.oppositeTeam(teamId);
    }
    
    public static MatchPairing getMatchPairing(String teamId, List<MatchPairing> round) {
        for (MatchPairing matchPairing : round) {
            if (matchPairing.containsTeam(teamId)) {
                return matchPairing;
            }
        }
        return null;
    }
    
    public int getCurrentRoundIndex() {
        return currentRoundIndex;
    }
    
    public int getMaxRounds() {
        return schedule.size();
    }
    
    /**
     * Initialize the RoundManager to handle rounds for a game
     * @param teamIds the teamIds of the teams in the round (must have at least 2 entries)
     * @param numOfArenas the number of arenas (must be greater than 0)
     */
    public void initialize(@NotNull List<@NotNull String> teamIds, int numOfArenas) {
        Preconditions.checkArgument(teamIds.size() >= 2, "There must be at least two teamIds (got %s)", teamIds.size());
        Preconditions.checkArgument(numOfArenas > 0, "there must be at least 1 arena");
        Set<String> uniqueTeams = new HashSet<>(teamIds);
        Preconditions.checkArgument(uniqueTeams.size() == teamIds.size(), "Duplicate teamId found in teamIds %s", teamIds.toString());
        this.schedule = generateSchedule(teamIds, numOfArenas);
        currentRoundIndex = 0;
    }
    
    /**
     * If this returns true, you can safely run {@link #nextRound()} to cycle to the next round, then {@link #getCurrentRound()} to get the list of match pairings for the round you just iterated to.
     * @return true if there is at least one un-played round next, false if there are no more rounds
     */
    public boolean hasNextRound() {
        return currentRoundIndex + 1 < schedule.size();
    }
    
    /**
     * Cycle to the next round. Don't run this without first checking {@link #hasNextRound()}. After iterating the round, you can get the new list of MatchPairings from {@link #getCurrentRound()}. 
     */
    public void nextRound() {
        currentRoundIndex++;
    }
    
    /**
     * @return the list of {@link MatchPairing}s for the current round.
     * @throws ArrayIndexOutOfBoundsException if you ran {@link #nextRound()} after {@link #hasNextRound()} returned false. 
     */
    public List<MatchPairing> getCurrentRound() {
        return schedule.get(currentRoundIndex);
    }
    
    public static List<List<MatchPairing>> generateSchedule(@NotNull List<String> teamIds, int numOfArenas) {
        return generateSchedule(teamIds, numOfArenas, Collections.emptyList());
    }
    
    /**
     * Generates a schedule for the teams to face off. This was generated by ChatGPT then modified slightly to
     * fit the application. 
     * @param teamIds the teamIds to generate the schedule for
     * @param numOfArenas the number of arenas (each arena fits 2 teams)
     * @return A list where each entry is the {@code numOfArenas} {@link MatchPairing}s for each round. The size
     * of the returned list will be the number of rounds. 
     */
    public static List<List<MatchPairing>> generateSchedule(@NotNull List<String> teamIds, 
                                                            int numOfArenas, 
                                                            @NotNull List<MatchPairing> exclude) {
        int numOfTeams = teamIds.size();
        List<List<MatchPairing>> schedule = new ArrayList<>();
        int numOfRounds = (numOfTeams % 2 == 0) ? numOfTeams - 1 : numOfTeams;
        
        // Clone the teams list so as not to modify the original
        List<String> rotatingTeams = new ArrayList<>(teamIds);
        
        for (int round = 0; round < numOfRounds; round++) {
            List<MatchPairing> roundMatches = new ArrayList<>();
            
            for (int i = 0; i < numOfTeams / 2; i++) {
                int index = numOfTeams - 1 - i;
                MatchPairing match = new MatchPairing(rotatingTeams.get(i), rotatingTeams.get(index));
                if (!exclude.contains(match)) {
                    roundMatches.add(match);
                }
            }
            
            // Rotate teams, keeping the first one fixed
            rotatingTeams.add(1, rotatingTeams.removeLast());
            
            // Split matches into groups for each arena
            for (int i = 0; i < roundMatches.size(); i += numOfArenas) {
                int end = Math.min(i + numOfArenas, roundMatches.size());
                schedule.add(new ArrayList<>(roundMatches.subList(i, end)));
            }
        }
        
        return schedule;
    }
    
}
