package org.braekpo1nt.mctmanager.games.game.capturetheflag;

import com.google.common.base.Preconditions;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class RoundManager {
    
    /**
     * The schedule handled by this round. Each element of the outer list
     * is a round. 
     */
    private List<List<MatchPairing>> schedule;
    
    private int currentRoundIndex = 0;
    
    /**
     * @param teamId the teamId to check
     * @param round the round to check
     * @return true if the given teamId is playing in the given round, false if they are on-deck
     */
    public static boolean teamIsPlaying(String teamId, List<MatchPairing> round) {
        for (MatchPairing matchPairing : round) {
            if (matchPairing.containsTeam(teamId)) {
                return true;
            }
        }
        return false;
    }
    
    /**
     * @param teamId the teamId to check
     * @param round the round to check
     * @return the opposite teamId of the given teamId in the given round (if they are present), null if the given team is on-deck
     */
    public static @Nullable String getOppositeTeam(String teamId, List<MatchPairing> round) {
        MatchPairing matchPairing = getMatchPairing(teamId, round);
        if (matchPairing == null) {
            return null;
        }
        return matchPairing.oppositeTeam(teamId);
    }
    
    public static MatchPairing getMatchPairing(String teamId, List<MatchPairing> round) {
        for (MatchPairing matchPairing : round) {
            if (matchPairing.containsTeam(teamId)) {
                return matchPairing;
            }
        }
        return null;
    }
    
    public int getCurrentRoundIndex() {
        return currentRoundIndex;
    }
    
    public int getMaxRounds() {
        return schedule.size();
    }
    
    /**
     * Initialize the RoundManager to handle rounds for a game
     * @param teamIds the teamIds of the teams in the round (must have at least 2 entries)
     * @param numOfArenas the number of arenas (must be greater than 0)
     */
    public void initialize(@NotNull List<@NotNull String> teamIds, int numOfArenas) {
        Preconditions.checkArgument(teamIds.size() >= 2, "There must be at least two teamIds (got %s)", teamIds.size());
        Preconditions.checkArgument(numOfArenas > 0, "there must be at least 1 arena");
        Set<String> uniqueTeams = new HashSet<>(teamIds);
        Preconditions.checkArgument(uniqueTeams.size() == teamIds.size(), "Duplicate teamId found in teamIds %s", teamIds.toString());
        this.schedule = generateSchedule(teamIds, numOfArenas);
        currentRoundIndex = 0;
        
    }
    
    /**
     * If this returns true, you can safely run {@link #nextRound()} to cycle to the next round, then {@link #getCurrentRound()} to get the list of match pairings for the round you just iterated to.
     * @return true if there is at least one un-played round next, false if there are no more rounds
     */
    public boolean hasNextRound() {
        return currentRoundIndex + 1 < schedule.size();
    }
    
    /**
     * Cycle to the next round. Don't run this without first checking {@link #hasNextRound()}. After iterating the round, you can get the new list of MatchPairings from {@link #getCurrentRound()}. 
     */
    public void nextRound() {
        currentRoundIndex++;
    }
    
    /**
     * @return the list of {@link MatchPairing}s for the current round.
     * @throws ArrayIndexOutOfBoundsException if you ran {@link #nextRound()} after {@link #hasNextRound()} returned false. 
     */
    public List<MatchPairing> getCurrentRound() {
        return schedule.get(currentRoundIndex);
    }
    
    
    /**
     * Generates a schedule for the teams to face off. This was generated by ChatGPT then modified slightly to
     * fit the application. 
     * @param teamIds the teamIds to generate the schedule for
     * @param numOfArenas the number of arenas (each arena fits 2 teams)
     * @return A list where each entry is the {@code numOfArenas} {@link MatchPairing}s for each round. The size
     * of the returned list will be the number of rounds. 
     */
    public static List<List<MatchPairing>> generateSchedule(List<String> teamIds, int numOfArenas) {
        int t = teamIds.size();
        List<List<MatchPairing>> schedule = new ArrayList<>();
        int rounds = (t % 2 == 0) ? t - 1 : t;
        
        // Clone the teams list so as not to modify the original
        List<String> rotatingTeams = new ArrayList<>(teamIds);
        
        for (int round = 0; round < rounds; round++) {
            List<MatchPairing> roundMatches = new ArrayList<>();
            
            for (int i = 0; i < t / 2; i++) {
                MatchPairing match = new MatchPairing(rotatingTeams.get(i), rotatingTeams.get(t - 1 - i));
                roundMatches.add(match);
            }
            
            // Rotate teams, keeping the first one fixed
            rotatingTeams.add(1, rotatingTeams.removeLast());
            
            // Split matches into groups for each arena
            for (int i = 0; i < roundMatches.size(); i += numOfArenas) {
                int end = Math.min(i + numOfArenas, roundMatches.size());
                schedule.add(new ArrayList<>(roundMatches.subList(i, end)));
            }
        }
        
        return schedule;
    }
    
}
